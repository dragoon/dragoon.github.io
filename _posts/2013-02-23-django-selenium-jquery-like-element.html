---
layout: post
title: "Django-selenium jquery-like element selector"
date: 2013-02-23
comments: false
categories:
- django-selenium
- django
- selenium
---

<div class='post'>
    You might know about <a
        href="https://pypi.python.org/pypi/django-selenium/0.9.5">django-selenium</a>, the tool
    <a href="https://github.com/dragoon/django-selenium/blob/master/AUTHORS">we developed</a>&nbsp;for
    django to provide the ability to write selenium tests as easy as normal django tests.
    Alongside we've also added numerous<b> helper methods</b>&nbsp;that incorporated common use
    cases of our (and hopefully other people's) selenium test writing experience (full list of
    methods is available at: <a
        href="https://django-selenium.readthedocs.org/en/latest/#mydriver-class">https://django-selenium.readthedocs.org/en/latest/#mydriver-class</a>)<br/><br/>Until
    recently, there still remained an annoying problem: django-selenium's find method could only
    operate on single (first) element of the css selector. That means when you need other
    element than the first one, you had to switch to native selenium' "<span
        style="font-family: Courier New, Courier, monospace;"><a
        href="http://selenium-python.readthedocs.org/en/latest/api.html#selenium.webdriver.remote.webdriver.find_elements_by_css_selector">find_elements_by_css_selector</a></span>"
    method. Luckily, this problem is solved beautifully in jquery, where by default you can
    operate on whole list of elements returned by selector, but at the same time single-element
    operations are applied to the first element of the list.<br/><br/>So, I decided to implement
    the same behaviour for django-selenium. In python it can be easily achieved using the
    special <span style="font-family: Courier New, Courier, monospace;"><a
        href="http://docs.python.org/2/reference/datamodel.html#object.__getattribute__">__getattribute__ </a></span>method,
    which allows to intercept every attribute access. Here is the first version of code for
    SeleniumElement that serves as a proxy to real selenium elements in django-selenium
    0.9.5:<br/>
    <pre><code class="python">class SeleniumElement(object):<br/>    def __init__(self, elements, selector):<br/>        self.elements = elements<br/>        self.selector = selector<br/><br/>    def __getattribute__(self, name):<br/>        """<br/>        Pass ``__getattribute__`` directly to the first array element.<br/>        """<br/>        attr = object.__getattribute__(self, 'elements')[0].__getattribute__(name)<br/>        return attr<br/><br/>    def __getitem__(self, key):<br/>        """<br/>        Return item from the internal sequence, bypassing ``__getattribute__``<br/>        """<br/>        return object.__getattribute__(self, 'elements')[key]<br/></code></pre>
    Shorty, __getattribute__ method overwrite will proxy every function call/attribute access to
    the underlying first element of the element list returned by selector, and __getitem__
    method overwrite will be called each time the element is accessed by index, thus returning
    the underlying element from the elements list. <br/><br/>Example from the tests:<br/>
    <pre>def test_multiple_elements(self):<br/>    test_list = ['one string', 'another string']<br/>    se = SeleniumElement(test_list, 'selector')<br/>    self.assertEquals(se.replace('one', 'two'), 'two string')<br/>    for i, elem in enumerate(se):<br/>        self.assertEquals(elem, test_list[i])<br/></pre>
</div>
